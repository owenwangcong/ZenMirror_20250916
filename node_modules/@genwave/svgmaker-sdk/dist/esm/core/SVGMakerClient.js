import { DEFAULT_CONFIG } from '../types/config';
import { HttpClient } from '../utils/httpClient';
import { ValidationError } from '../errors/CustomErrors';
import { GenerateClient } from '../clients/GenerateClient';
import { EditClient } from '../clients/EditClient';
import { ConvertClient } from '../clients/ConvertClient';
import { createRetryWrapper } from '../utils/retry';
import { createRateLimiter } from '../utils/rateLimit';
import { createLogger } from '../utils/logger';
/**
 * Main SVGMaker client
 */
export class SVGMakerClient {
    /**
     * Create a new SVGMaker client
     * @param apiKey API key for authentication
     * @param config Additional configuration options
     */
    constructor(apiKey, config = {}) {
        /**
         * Request interceptors
         */
        this.requestInterceptors = [];
        /**
         * Response interceptors
         */
        this.responseInterceptors = [];
        if (!apiKey) {
            throw new ValidationError('API key is required');
        }
        // Merge default config with provided config
        this.config = {
            ...DEFAULT_CONFIG,
            ...config,
            apiKey,
        };
        // Initialize logger
        this.logger = createLogger(this.config);
        // Create HTTP client
        this.httpClient = new HttpClient(this.config);
        // Apply retry wrapper and rate limiting
        const wrappedRequest = this.wrapRequestWithRetryAndRateLimit(this.httpClient.request.bind(this.httpClient));
        this.httpClient.request = wrappedRequest;
        // Add built-in response interceptor for base64 image decoding
        this.addResponseInterceptor(this.decodeBase64Images.bind(this));
        // Create API clients
        this.generate = new GenerateClient(this);
        this.edit = new EditClient(this);
        this.convert = new ConvertClient(this);
        this.logger.info('SVGMaker SDK initialized');
    }
    /**
     * Wrap request method with retry and rate limiting
     * @param request Original request method
     * @returns Wrapped request method
     */
    wrapRequestWithRetryAndRateLimit(request) {
        return async (url, options) => {
            const retryWrapper = createRetryWrapper(this.config);
            const rateLimiter = createRateLimiter(this.config);
            const wrappedRequest = rateLimiter(retryWrapper((u, o) => request(u, o)));
            return wrappedRequest(url, options);
        };
    }
    /**
     * Get the current configuration
     * @returns Current configuration
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * Update the client configuration
     * @param config Configuration options to update
     * @returns This client instance for chaining
     */
    setConfig(config) {
        this.config = {
            ...this.config,
            ...config,
        };
        this.logger.info('Configuration updated', config);
        return this;
    }
    /**
     * Get the HTTP client
     * @returns HTTP client
     */
    getHttpClient() {
        return this.httpClient;
    }
    /**
     * Add a request interceptor
     * @param interceptor Request interceptor function
     * @returns This client instance for chaining
     */
    addRequestInterceptor(interceptor) {
        this.requestInterceptors.push(interceptor);
        this.logger.debug('Request interceptor added');
        return this;
    }
    /**
     * Add a response interceptor
     * @param interceptor Response interceptor function
     * @returns This client instance for chaining
     */
    addResponseInterceptor(interceptor) {
        this.responseInterceptors.push(interceptor);
        this.logger.debug('Response interceptor added');
        return this;
    }
    /**
     * Apply request interceptors to a request
     * @param request Request to intercept
     * @returns Modified request
     */
    async applyRequestInterceptors(request) {
        let interceptedRequest = request;
        for (const interceptor of this.requestInterceptors) {
            interceptedRequest = await interceptor(interceptedRequest);
        }
        return interceptedRequest;
    }
    /**
     * Apply response interceptors to a response
     * @param response Response to intercept
     * @returns Modified response
     */
    async applyResponseInterceptors(response) {
        let interceptedResponse = response;
        for (const interceptor of this.responseInterceptors) {
            interceptedResponse = await interceptor(interceptedResponse);
        }
        return interceptedResponse;
    }
    /**
     * Built-in response interceptor to decode base64 PNG images
     * @param response Response to process
     * @returns Response with decoded image data
     */
    decodeBase64Images(response) {
        // Type guard to check if response has base64Png property
        if (typeof response === 'object' && response !== null && 'base64Png' in response) {
            const responseWithBase64 = response;
            if (typeof responseWithBase64.base64Png === 'string') {
                // Strip data URL prefix if present and decode base64
                const base64Data = responseWithBase64.base64Png.replace(/^data:image\/png;base64,/, '');
                const pngImageData = Buffer.from(base64Data, 'base64');
                // Create new response object with pngImageData instead of base64Png
                const { base64Png: _base64Png, ...responseWithoutBase64 } = responseWithBase64;
                return {
                    ...responseWithoutBase64,
                    pngImageData,
                };
            }
        }
        return response;
    }
    /**
     * Get the logger instance
     * @returns Logger instance
     */
    getLogger() {
        return this.logger;
    }
}
//# sourceMappingURL=SVGMakerClient.js.map