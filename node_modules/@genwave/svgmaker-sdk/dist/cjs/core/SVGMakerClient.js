"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SVGMakerClient = void 0;
const config_1 = require("../types/config");
const httpClient_1 = require("../utils/httpClient");
const CustomErrors_1 = require("../errors/CustomErrors");
const GenerateClient_1 = require("../clients/GenerateClient");
const EditClient_1 = require("../clients/EditClient");
const ConvertClient_1 = require("../clients/ConvertClient");
const retry_1 = require("../utils/retry");
const rateLimit_1 = require("../utils/rateLimit");
const logger_1 = require("../utils/logger");
/**
 * Main SVGMaker client
 */
class SVGMakerClient {
    /**
     * Create a new SVGMaker client
     * @param apiKey API key for authentication
     * @param config Additional configuration options
     */
    constructor(apiKey, config = {}) {
        /**
         * Request interceptors
         */
        this.requestInterceptors = [];
        /**
         * Response interceptors
         */
        this.responseInterceptors = [];
        if (!apiKey) {
            throw new CustomErrors_1.ValidationError('API key is required');
        }
        // Merge default config with provided config
        this.config = {
            ...config_1.DEFAULT_CONFIG,
            ...config,
            apiKey,
        };
        // Initialize logger
        this.logger = (0, logger_1.createLogger)(this.config);
        // Create HTTP client
        this.httpClient = new httpClient_1.HttpClient(this.config);
        // Apply retry wrapper and rate limiting
        const wrappedRequest = this.wrapRequestWithRetryAndRateLimit(this.httpClient.request.bind(this.httpClient));
        this.httpClient.request = wrappedRequest;
        // Add built-in response interceptor for base64 image decoding
        this.addResponseInterceptor(this.decodeBase64Images.bind(this));
        // Create API clients
        this.generate = new GenerateClient_1.GenerateClient(this);
        this.edit = new EditClient_1.EditClient(this);
        this.convert = new ConvertClient_1.ConvertClient(this);
        this.logger.info('SVGMaker SDK initialized');
    }
    /**
     * Wrap request method with retry and rate limiting
     * @param request Original request method
     * @returns Wrapped request method
     */
    wrapRequestWithRetryAndRateLimit(request) {
        return async (url, options) => {
            const retryWrapper = (0, retry_1.createRetryWrapper)(this.config);
            const rateLimiter = (0, rateLimit_1.createRateLimiter)(this.config);
            const wrappedRequest = rateLimiter(retryWrapper((u, o) => request(u, o)));
            return wrappedRequest(url, options);
        };
    }
    /**
     * Get the current configuration
     * @returns Current configuration
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * Update the client configuration
     * @param config Configuration options to update
     * @returns This client instance for chaining
     */
    setConfig(config) {
        this.config = {
            ...this.config,
            ...config,
        };
        this.logger.info('Configuration updated', config);
        return this;
    }
    /**
     * Get the HTTP client
     * @returns HTTP client
     */
    getHttpClient() {
        return this.httpClient;
    }
    /**
     * Add a request interceptor
     * @param interceptor Request interceptor function
     * @returns This client instance for chaining
     */
    addRequestInterceptor(interceptor) {
        this.requestInterceptors.push(interceptor);
        this.logger.debug('Request interceptor added');
        return this;
    }
    /**
     * Add a response interceptor
     * @param interceptor Response interceptor function
     * @returns This client instance for chaining
     */
    addResponseInterceptor(interceptor) {
        this.responseInterceptors.push(interceptor);
        this.logger.debug('Response interceptor added');
        return this;
    }
    /**
     * Apply request interceptors to a request
     * @param request Request to intercept
     * @returns Modified request
     */
    async applyRequestInterceptors(request) {
        let interceptedRequest = request;
        for (const interceptor of this.requestInterceptors) {
            interceptedRequest = await interceptor(interceptedRequest);
        }
        return interceptedRequest;
    }
    /**
     * Apply response interceptors to a response
     * @param response Response to intercept
     * @returns Modified response
     */
    async applyResponseInterceptors(response) {
        let interceptedResponse = response;
        for (const interceptor of this.responseInterceptors) {
            interceptedResponse = await interceptor(interceptedResponse);
        }
        return interceptedResponse;
    }
    /**
     * Built-in response interceptor to decode base64 PNG images
     * @param response Response to process
     * @returns Response with decoded image data
     */
    decodeBase64Images(response) {
        // Type guard to check if response has base64Png property
        if (typeof response === 'object' && response !== null && 'base64Png' in response) {
            const responseWithBase64 = response;
            if (typeof responseWithBase64.base64Png === 'string') {
                // Strip data URL prefix if present and decode base64
                const base64Data = responseWithBase64.base64Png.replace(/^data:image\/png;base64,/, '');
                const pngImageData = Buffer.from(base64Data, 'base64');
                // Create new response object with pngImageData instead of base64Png
                const { base64Png: _base64Png, ...responseWithoutBase64 } = responseWithBase64;
                return {
                    ...responseWithoutBase64,
                    pngImageData,
                };
            }
        }
        return response;
    }
    /**
     * Get the logger instance
     * @returns Logger instance
     */
    getLogger() {
        return this.logger;
    }
}
exports.SVGMakerClient = SVGMakerClient;
//# sourceMappingURL=SVGMakerClient.js.map