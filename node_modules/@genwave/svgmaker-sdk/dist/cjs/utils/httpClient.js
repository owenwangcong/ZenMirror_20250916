"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const stream_1 = require("stream");
const CustomErrors_1 = require("../errors/CustomErrors");
/**
 * HTTP client for making requests to the SVGMaker API
 */
class HttpClient {
    /**
     * Create a new HTTP client
     * @param config SDK configuration
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Make a request to the SVGMaker API
     * @param url Request URL
     * @param options Request options
     * @returns Promise with the response data
     * @throws {APIError} If the API returns an error
     * @throws {TimeoutError} If the request times out
     * @throws {NetworkError} If there's a network error
     */
    async request(url, options = {}) {
        const fullUrl = this.buildUrl(url, options.params);
        const timeout = options.timeout || this.config.timeout;
        // Create abort controller for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
        }, timeout);
        try {
            // Prepare request options
            const fetchOptions = {
                ...options,
                headers: this.buildHeaders(options),
                signal: controller.signal,
            };
            // Handle form data
            if (options.formData) {
                fetchOptions.body = options.formData;
                // Let form-data set the content-type header with boundary
                delete fetchOptions.headers['Content-Type'];
            }
            const response = await fetch(fullUrl, fetchOptions);
            clearTimeout(timeoutId);
            // Handle API errors
            if (!response.ok) {
                throw await this.handleErrorResponse(response);
            }
            // Parse response
            if (response.headers.get('Content-Type')?.includes('application/json')) {
                const jsonResponse = await response.json();
                // Process base64Png field if present
                if (jsonResponse.base64Png && typeof jsonResponse.base64Png === 'string') {
                    // Convert base64 PNG to Buffer for consistent API
                    const base64Data = jsonResponse.base64Png.replace(/^data:image\/png;base64,/, '');
                    jsonResponse.pngImageData = Buffer.from(base64Data, 'base64');
                    // Keep the original base64 string as well for compatibility
                }
                return jsonResponse;
            }
            else {
                return (await response.text());
            }
        }
        catch (error) {
            clearTimeout(timeoutId);
            // Handle aborted requests (timeouts)
            if (error.name === 'AbortError') {
                throw new CustomErrors_1.TimeoutError(`Request timed out after ${timeout}ms`, timeout);
            }
            // Re-throw API errors
            if (error instanceof CustomErrors_1.APIError) {
                throw error;
            }
            // Handle network errors
            throw new CustomErrors_1.NetworkError(`Network error: ${error.message}`, error);
        }
    }
    /**
     * Make a GET request
     * @param url Request URL
     * @param options Request options
     * @returns Promise with the response data
     */
    async get(url, options = {}) {
        return this.request(url, {
            ...options,
            method: 'GET',
        });
    }
    /**
     * Make a POST request
     * @param url Request URL
     * @param data Request body data
     * @param options Request options
     * @returns Promise with the response data
     */
    async post(url, data, options = {}) {
        const contentType = options.headers?.['Content-Type'] || 'application/json';
        if (contentType === 'application/json' && typeof data === 'object' && data !== null) {
            return this.request(url, {
                ...options,
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers,
                },
                body: JSON.stringify(data),
            });
        }
        else if (data instanceof globalThis.FormData || options.formData) {
            const formData = data instanceof globalThis.FormData ? data : options.formData;
            return this.request(url, {
                ...options,
                method: 'POST',
                formData,
            });
        }
        else {
            return this.request(url, {
                ...options,
                method: 'POST',
                body: data,
            });
        }
    }
    /**
     * Create a FormData object from file input
     * @param fieldName Form field name
     * @param file File input (path, buffer, or stream)
     * @returns FormData object
     */
    async createFormData(fieldName, file) {
        const formData = new FormData();
        if (typeof file === 'string') {
            // File path - read as buffer and create blob
            const fs = await Promise.resolve().then(() => __importStar(require('fs')));
            const path = await Promise.resolve().then(() => __importStar(require('path')));
            if (!fs.existsSync(file)) {
                throw new Error(`File not found: ${file}`);
            }
            const fileBuffer = fs.readFileSync(file);
            const filename = path.basename(file);
            const blob = new Blob([fileBuffer]);
            formData.append(fieldName, blob, filename);
        }
        else if (Buffer.isBuffer(file)) {
            // Buffer - convert to blob
            const blob = new Blob([file]);
            formData.append(fieldName, blob, 'file');
        }
        else if (file instanceof stream_1.Readable) {
            // Readable stream - convert to buffer then blob
            const chunks = [];
            for await (const chunk of file) {
                chunks.push(Buffer.from(chunk));
            }
            const buffer = Buffer.concat(chunks);
            const blob = new Blob([buffer]);
            formData.append(fieldName, blob, 'file');
        }
        else {
            throw new Error(`Unsupported file type: ${typeof file}`);
        }
        return formData;
    }
    /**
     * Build the full URL with query parameters
     * @param url Base URL
     * @param params Query parameters
     * @returns Full URL
     */
    buildUrl(url, params) {
        const baseUrl = url.startsWith('http')
            ? url
            : `${this.config.baseUrl}${url.startsWith('/') ? url : `/${url}`}`;
        if (!params) {
            return baseUrl;
        }
        const queryParams = Object.entries(params)
            .filter(([_, value]) => value !== undefined)
            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
            .join('&');
        return queryParams ? `${baseUrl}?${queryParams}` : baseUrl;
    }
    /**
     * Build request headers
     * @param options Request options
     * @returns Headers object
     */
    buildHeaders(options) {
        const headers = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            'x-api-key': this.config.apiKey,
            ...options.headers,
        };
        return headers;
    }
    /**
     * Handle API error responses
     * @param response Error response
     * @returns Error object
     */
    async handleErrorResponse(response) {
        let errorData = {};
        try {
            if (response.headers.get('Content-Type')?.includes('application/json')) {
                errorData = await response.json();
            }
            else {
                errorData = { error: await response.text() };
            }
        }
        catch {
            errorData = { error: `HTTP Error ${response.status}` };
        }
        const message = errorData.error || errorData.details || `HTTP Error ${response.status}`;
        // Handle specific error types
        switch (response.status) {
            case 401:
                return new CustomErrors_1.AuthError(message);
            case 402:
                return new CustomErrors_1.InsufficientCreditsError(message, errorData.creditsRequired);
            case 413:
                return new CustomErrors_1.FileSizeError(message);
            case 429:
                return new CustomErrors_1.RateLimitError(message, parseInt(response.headers.get('Retry-After') || '60', 10));
        }
        // Handle content safety errors
        if (errorData.errorType === 'content_safety') {
            return new CustomErrors_1.ContentSafetyError(message);
        }
        // Handle file format errors
        if (message.includes('file format') ||
            message.includes('SVG files are already in vector format')) {
            return new CustomErrors_1.FileFormatError(message);
        }
        // Generic API error
        return new CustomErrors_1.APIError(message, response.status, errorData.errorType || errorData.error_type, errorData.details);
    }
}
exports.HttpClient = HttpClient;
//# sourceMappingURL=httpClient.js.map