"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRateLimiter = createRateLimiter;
/**
 * Simple rate limiter implementation
 */
class RateLimiter {
    constructor(limit, windowMs) {
        this.requestTimes = [];
        this.limit = limit;
        this.windowMs = windowMs;
    }
    async acquire() {
        const now = Date.now();
        // Remove old requests outside the window
        this.requestTimes = this.requestTimes.filter(time => now - time < this.windowMs);
        // If we're at the limit, wait
        if (this.requestTimes.length >= this.limit) {
            const oldestRequest = this.requestTimes[0];
            const waitTime = this.windowMs - (now - oldestRequest);
            if (waitTime > 0) {
                await new Promise(resolve => setTimeout(resolve, waitTime));
                return this.acquire(); // Try again after waiting
            }
        }
        // Record this request
        this.requestTimes.push(now);
    }
}
/**
 * Creates a rate limiter for API requests
 * @param config SDK configuration containing rate limit settings
 * @returns Function that wraps API calls with rate limiting
 */
function createRateLimiter(config) {
    // Convert requests per minute to interval
    const requestsPerMinute = config.rateLimit;
    const intervalMs = 60 * 1000; // 1 minute in milliseconds
    const rateLimiter = new RateLimiter(requestsPerMinute, intervalMs);
    /**
     * Wraps an async function with rate limiting
     * @param fn Function to throttle
     * @returns Rate-limited function
     */
    return function rateLimitWrapper(fn) {
        return async (url, options) => {
            await rateLimiter.acquire();
            if (config.logging) {
                console.log('Rate limiting applied to request');
            }
            return fn(url, options);
        };
    };
}
//# sourceMappingURL=rateLimit.js.map